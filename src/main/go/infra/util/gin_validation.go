package util

import (
	"errors"
	"fmt"
	"github.com/benizzio/open-asset-allocator/api/rest/model"
	"github.com/gin-gonic/gin"
	"github.com/go-playground/validator/v10"
	"net/http"
	"reflect"
	"strings"
)

// BindAndValidateJSON binds the request body to the provided struct and validates it.
// It handles validation errors by returning appropriate HTTP responses.
// (this function was generated by AI)
func BindAndValidateJSON(context *gin.Context, bindingTarget interface{}) (bool, error) {
	if err := context.ShouldBindJSON(bindingTarget); err == nil {
		return true, nil
	} else if validationErrors := extractValidationErrors(err); validationErrors != nil {
		// Handle validation errors
		errorMessages := formatValidationErrorMessages(validationErrors, bindingTarget)
		sendValidationErrorResponse(context, errorMessages)
		return false, nil
	} else {
		// Handle non-validation errors
		return false, err
	}
}

// extractValidationErrors attempts to extract validation errors from the given error.
// Returns nil if the error is not a validation error.
// (this function was generated by AI)
func extractValidationErrors(inputError error) validator.ValidationErrors {
	var validationErrors validator.ValidationErrors
	if errors.As(inputError, &validationErrors) {
		return validationErrors
	}
	return nil
}

// formatErrorMessage formats a single validation error into a human-readable message.
// (this function was generated by AI)
func formatErrorMessage(validationError validator.FieldError, structType reflect.Type) string {
	// Extract needed information from validation error
	namespace := validationError.Namespace()
	fieldName := validationError.Field()
	jsonFieldName := getJSONFieldName(namespace, fieldName, structType)

	return fmt.Sprintf(
		"Field '%s' failed validation: %s",
		jsonFieldName,
		formatValidationError(validationError),
	)
}

// formatValidationErrorMessages converts validation errors into human-readable messages.
// (this function was generated by AI)
func formatValidationErrorMessages(validationErrors validator.ValidationErrors, targetStruct interface{}) []string {
	errorMessages := make([]string, 0, len(validationErrors))
	structType := reflect.TypeOf(targetStruct)
	if structType.Kind() == reflect.Ptr {
		structType = structType.Elem()
	}

	for _, validationError := range validationErrors {
		message := formatErrorMessage(validationError, structType)
		errorMessages = append(errorMessages, message)
	}

	return errorMessages
}

// sendValidationErrorResponse sends a standardized HTTP response for validation errors.
// (this function was generated by AI)
func sendValidationErrorResponse(context *gin.Context, errorMessages []string) {
	context.JSON(
		http.StatusBadRequest, model.ErrorResponse{
			ErrorMessage: "Validation failed",
			Details:      errorMessages,
		},
	)
}

// formatValidationError formats validation errors into readable messages.
// (this function was generated by AI)
func formatValidationError(fieldError validator.FieldError) string {
	switch fieldError.Tag() {
	case "required":
		return "is required"
	case "min":
		return fmt.Sprintf("must be at least %s", fieldError.Param())
	case "max":
		return fmt.Sprintf("must not exceed %s", fieldError.Param())
	default:
		return fieldError.Tag()
	}
}

// getNamespaceInfo extracts field name and builds the full namespace
// (this function was generated by AI)
func getNamespaceInfo(structName, fieldNamespace string) (namespace, fieldName string) {
	parts := strings.Split(fieldNamespace, ".")

	// Handle nested fields vs simple fields
	if len(parts) > 1 {
		// For nested fields, take the last part as the field name
		fieldName = parts[len(parts)-1]

		// Check if namespace already starts with struct name
		if strings.HasPrefix(fieldNamespace, structName+".") {
			namespace = fieldNamespace
		} else {
			namespace = structName + "." + fieldNamespace
		}
	} else {
		// Simple field (no dots)
		fieldName = fieldNamespace
		namespace = structName + "." + fieldNamespace
	}

	return namespace, fieldName
}

// CreateCustomValidationError creates a custom validation error that implements validator.FieldError.
// This allows you to generate validation errors programmatically and use them with existing
// validation error handling code.
// (this function was generated by AI)
//
// Parameters:
//   - targetStruct: The struct or pointer to struct that contains the field
//   - fieldNamespace: The namespace of the field (e.g., "User.Address.Street" or just "Email")
//   - tag: The validation tag that failed (e.g., "required", "min", "max", "email")
//   - param: Additional parameter for the validation tag:
//   - For "min" tag: The minimum value (e.g., "5" for min=5)
//   - For "max" tag: The maximum value (e.g., "100" for max=100)
//   - For "len" tag: The exact length (e.g., "10" for len=10)
//   - For "eq" tag: The equal value (e.g., "active" for eq=active)
//   - For "required", "email", etc.: Leave empty ("")
//   - value: The actual value that failed validation:
//   - For "min" tag with numbers: The numeric value that's too small (e.g., 3 when min=5)
//   - For "max" tag with numbers: The numeric value that's too large (e.g., 150 when max=100)
//   - For "required" tag: Empty value ("", nil, 0, etc.)
//   - For "email" tag: The invalid email string (e.g., "notanemail")
//
// Returns:
//   - A validator.FieldError that can be used with the formatValidationErrorMessages function
//
// Example:
//
//	// Create a validation error for a required email field on User struct
//	user := User{}
//	emailError := util.CreateCustomValidationError(
//	    user,           // Target struct
//	    "Email",        // Field namespace
//	    "required",     // Validation tag
//	    "",             // No parameter needed for "required" tag
//	    "",             // Empty value that caused the validation failure
//	)
//
//	// Create a validation error for a minimum value constraint
//	ageError := util.CreateCustomValidationError(
//	    user,           // Target struct
//	    "Age",          // Field namespace
//	    "min",          // Validation tag
//	    "18",           // Parameter - minimum age is 18
//	    16,             // Value that failed - 16 is less than minimum 18
//	)
//
//	// Create a validation error for a nested field with max length
//	addressError := util.CreateCustomValidationError(
//	    user,                  // Target struct
//	    "Address.Street",      // Field namespace (nested)
//	    "max",                 // Validation tag
//	    "100",                 // Parameter - max length is 100
//	    "This street name is way too long and exceeds the maximum character limit",  // Value that failed
//	)
func CreateCustomValidationError(
	targetStruct interface{},
	fieldNamespace,
	tag,
	param string,
	value interface{},
) validator.FieldError {
	// Get struct name using reflection
	structName := getStructName(targetStruct)

	// Parse the field namespace to get the full namespace and field name
	namespace, fieldName := getNamespaceInfo(structName, fieldNamespace)

	// Create and return the custom validation error
	return CustomFieldError{
		field:           fieldName,
		structField:     fieldName,
		namespace:       namespace,
		structNamespace: namespace,
		tagValue:        tag,
		paramValue:      param,
		valueValue:      value,
	}
}

// getStructName extracts the struct name from a struct or pointer to struct
// (this function was generated by AI)
func getStructName(targetStruct interface{}) string {
	structType := reflect.TypeOf(targetStruct)

	// Handle pointer types
	if structType.Kind() == reflect.Ptr {
		structType = structType.Elem()
	}

	return structType.Name()
}

// CreateCustomValidationErrors creates a collection of validation errors that implements validator.ValidationErrors.
// (this function was generated by AI)
//
// Parameters:
//   - errors: A variadic list of validator.FieldError objects, typically created with CreateCustomValidationError
//
// Returns:
//   - validator.ValidationErrors that can be used with validation error handling functions
//
// Example:
//
//	// Create multiple validation errors
//	validationErrors := util.CreateCustomValidationErrors(
//	    util.CreateCustomValidationError("User", "Email", "required", "", ""),
//	    util.CreateCustomValidationError("User", "Age", "min", "18", 16),
//	    util.CreateCustomValidationError("User", "Password", "min", "8", "pass")
//	)
//
//	// Use with existing error handling
//	errorMessages := util.formatValidationErrorMessages(validationErrors, userObject)
//	util.sendValidationErrorResponse(ctx, errorMessages)
//
//	// Or return directly as an error
//	return validationErrors
func CreateCustomValidationErrors(errors ...validator.FieldError) validator.ValidationErrors {
	// CustomValidationErrors satisfies the validator.ValidationErrors interface
	return validator.ValidationErrors(customValidationErrors(errors))
}

// RespondWithCustomValidationErrors takes custom validation errors and sends a standardized
// validation error response using Gin. This is useful when you want to send validation errors
// that were generated programmatically rather than from binding/validation.
// (this function was generated by AI)
//
// Parameters:
//   - context: The Gin context used to send the HTTP response
//   - validationErrors: Custom validation errors created with CreateCustomValidationError
//   - targetStruct: The struct that contains field information (used for JSON field names)
//
// Example:
//
//	// Create custom validation errors
//	errors := []validator.FieldError{
//	    util.CreateCustomValidationError("User", "Email", "required", "", ""),
//	    util.CreateCustomValidationError("User", "Age", "min", "18", 16),
//	}
//
//	// Send HTTP response with these errors
//	util.RespondWithCustomValidationErrors(ctx, errors, userObject)
func RespondWithCustomValidationErrors(
	context *gin.Context,
	validationErrors validator.ValidationErrors,
	targetStruct interface{},
) {
	// Format the error messages using the existing formatValidationErrorMessages function
	errorMessages := formatValidationErrorMessages(validationErrors, targetStruct)

	// Send the validation error response using the existing function
	sendValidationErrorResponse(context, errorMessages)
}
